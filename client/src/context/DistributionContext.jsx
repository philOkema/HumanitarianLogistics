import React, { createContext, useContext, useState, useEffect, useCallback } from 'react';
import { useUser } from './UserContext';
import { useInventory } from './InventoryContext';
import { useAidRequest, REQUEST_STATUS } from './AidRequestContext';
import { useToast } from '@/hooks/use-toast';

// Define distribution status constants
export const DISTRIBUTION_STATUS = {
  PENDING: 'pending',
  PREPARING: 'preparing',
  READY_FOR_PICKUP: 'ready_for_pickup',
  IN_TRANSIT: 'in_transit',
  DELIVERED: 'delivered',
  CANCELLED: 'cancelled'
};

// Create context
const DistributionContext = createContext();

export const DistributionProvider = ({ children }) => {
  const { currentUser } = useUser();
  const { inventory, adjustQuantity } = useInventory();
  const { updateRequestStatus } = useAidRequest();
  const { toast } = useToast();
  
  const [distributions, setDistributions] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [lastUpdate, setLastUpdate] = useState(null);

  // Function to fetch distributions
  // In a real app, this would be an API call
  const fetchDistributions = useCallback(async () => {
    try {
      setLoading(true);
      
      // Simulate API call delay
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      // Mock data - in a real application, this would be fetched from an API
      const mockDistributions = JSON.parse(localStorage.getItem('distributions')) || [];
      
      setDistributions(mockDistributions);
      setLastUpdate(new Date());
      setError(null);
    } catch (err) {
      console.error('Error fetching distributions:', err);
      setError('Failed to load distributions. Please try again later.');
    } finally {
      setLoading(false);
    }
  }, []);

  // Initial data fetch
  useEffect(() => {
    fetchDistributions();
    
    // Set up polling for real-time updates
    const intervalId = setInterval(() => {
      fetchDistributions();
    }, 30000); // Update every 30 seconds
    
    return () => clearInterval(intervalId);
  }, [fetchDistributions]);

  // Function to get a specific distribution by ID
  const getDistributionById = useCallback((id) => {
    return distributions.find(dist => dist.id === parseInt(id));
  }, [distributions]);

  // Function to get distributions by request ID
  const getDistributionsByRequestId = useCallback((requestId) => {
    return distributions.filter(dist => dist.requestId === parseInt(requestId));
  }, [distributions]);

  // Function to create a new distribution
  const createDistribution = useCallback(async (distributionData) => {
    try {
      // In a real app, this would be an API call
      
      // Validate that there's enough inventory
      const insufficientItems = distributionData.items.filter(item => {
        const inventoryItem = inventory.find(invItem => invItem.id === item.itemId);
        return !inventoryItem || inventoryItem.quantity < item.quantity;
      });
      
      if (insufficientItems.length > 0) {
        const itemNames = insufficientItems.map(item => item.name).join(', ');
        return {
          success: false,
          error: `Insufficient inventory for: ${itemNames}`
        };
      }
      
      // Create a new distribution object
      const newDistribution = {
        id: Date.now(), // Use timestamp as ID (would be generated by backend in real app)
        ...distributionData,
        status: DISTRIBUTION_STATUS.PENDING,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString()
      };
      
      // Update local state and storage (simulating backend persistence)
      const updatedDistributions = [...distributions, newDistribution];
      setDistributions(updatedDistributions);
      localStorage.setItem('distributions', JSON.stringify(updatedDistributions));
      
      // Update the request status to IN_PROGRESS
      await updateRequestStatus(distributionData.requestId, REQUEST_STATUS.IN_PROGRESS);
      
      // Adjust inventory quantities (reserve the items)
      distributionData.items.forEach(item => {
        adjustQuantity(
          item.itemId, 
          -item.quantity, 
          `Reserved for distribution #${newDistribution.id}`
        );
      });
      
      setLastUpdate(new Date());
      
      return {
        success: true,
        distribution: newDistribution
      };
    } catch (err) {
      console.error('Error creating distribution:', err);
      return {
        success: false,
        error: 'Failed to create distribution. Please try again.'
      };
    }
  }, [distributions, inventory, updateRequestStatus, adjustQuantity]);

  // Function to update distribution status
  const updateDistributionStatus = useCallback(async (distributionId, newStatus) => {
    try {
      const distribution = getDistributionById(distributionId);
      
      if (!distribution) {
        return {
          success: false,
          error: 'Distribution not found'
        };
      }
      
      // Update the distribution
      const updatedDistribution = {
        ...distribution,
        status: newStatus,
        updatedAt: new Date().toISOString()
      };
      
      // Update local state and storage
      const updatedDistributions = distributions.map(dist => 
        dist.id === parseInt(distributionId) ? updatedDistribution : dist
      );
      
      setDistributions(updatedDistributions);
      localStorage.setItem('distributions', JSON.stringify(updatedDistributions));
      
      // Update the request status based on distribution status
      let requestStatus;
      switch (newStatus) {
        case DISTRIBUTION_STATUS.PREPARING:
          requestStatus = REQUEST_STATUS.IN_PROGRESS;
          break;
        case DISTRIBUTION_STATUS.READY_FOR_PICKUP:
          requestStatus = REQUEST_STATUS.READY_FOR_PICKUP;
          break;
        case DISTRIBUTION_STATUS.IN_TRANSIT:
          requestStatus = REQUEST_STATUS.IN_TRANSIT;
          break;
        case DISTRIBUTION_STATUS.DELIVERED:
          requestStatus = REQUEST_STATUS.DELIVERED;
          break;
        case DISTRIBUTION_STATUS.CANCELLED:
          requestStatus = REQUEST_STATUS.CANCELLED;
          break;
        default:
          requestStatus = null;
      }
      
      if (requestStatus) {
        await updateRequestStatus(distribution.requestId, requestStatus);
      }
      
      setLastUpdate(new Date());
      
      return {
        success: true,
        distribution: updatedDistribution
      };
    } catch (err) {
      console.error('Error updating distribution status:', err);
      return {
        success: false,
        error: 'Failed to update distribution status. Please try again.'
      };
    }
  }, [distributions, getDistributionById, updateRequestStatus]);

  // Function to cancel a distribution
  const cancelDistribution = useCallback(async (distributionId) => {
    try {
      const distribution = getDistributionById(distributionId);
      
      if (!distribution) {
        return {
          success: false,
          error: 'Distribution not found'
        };
      }
      
      // Can only cancel if not delivered
      if (distribution.status === DISTRIBUTION_STATUS.DELIVERED) {
        return {
          success: false,
          error: 'Cannot cancel a delivered distribution'
        };
      }
      
      // Update distribution status
      const result = await updateDistributionStatus(distributionId, DISTRIBUTION_STATUS.CANCELLED);
      
      if (result.success) {
        // Return items to inventory only if they were reserved (not delivered)
        if (distribution.status !== DISTRIBUTION_STATUS.DELIVERED) {
          distribution.items.forEach(item => {
            adjustQuantity(
              item.itemId, 
              item.quantity, 
              `Returned from cancelled distribution #${distributionId}`
            );
          });
        }
      }
      
      return result;
    } catch (err) {
      console.error('Error cancelling distribution:', err);
      return {
        success: false,
        error: 'Failed to cancel distribution. Please try again.'
      };
    }
  }, [getDistributionById, updateDistributionStatus, adjustQuantity]);

  // Function to get distributions by status
  const getDistributionsByStatus = useCallback((status) => {
    return distributions.filter(dist => dist.status === status);
  }, [distributions]);

  // Check if user can create distributions
  const canCreateDistribution = useCallback(() => {
    if (!currentUser) return false;
    return ['admin', 'staff'].includes(currentUser.role);
  }, [currentUser]);

  // Provide context value
  const contextValue = {
    distributions,
    loading,
    error,
    lastUpdate,
    getDistributionById,
    getDistributionsByRequestId,
    getDistributionsByStatus,
    createDistribution,
    updateDistributionStatus,
    cancelDistribution,
    canCreateDistribution,
    refresh: fetchDistributions
  };

  return (
    <DistributionContext.Provider value={contextValue}>
      {children}
    </DistributionContext.Provider>
  );
};

// Custom hook to use the Distribution context
export const useDistribution = () => {
  const context = useContext(DistributionContext);
  
  if (!context) {
    throw new Error('useDistribution must be used within a DistributionProvider');
  }
  
  return context;
};